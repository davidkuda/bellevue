SET ROLE dev;

BEGIN;

----------------------------------------------------------------------------------
-- create a generic model for products and prices --------------------------------
----------------------------------------------------------------------------------
-- NOTE: -------------------------------------------------------------------------
-- ANSISQL is current_timestamp, PostgreSQL is now() (but you can use both in PG).
-- It refers to the start of the transaction, not point of execution. ------------
----------------------------------------------------------------------------------
-- NOTE: -------------------------------------------------------------------------
-- use `id INT generated by default as identity primary key,` insetad ------------
-- of `id serial`, see https://stackoverflow.com/a/55300741/14501123 -------------


create table bellevue.price_categories (
	id INT generated by default as identity primary key,
	name TEXT unique not null, -- reduced, regular, surplus
	description TEXT,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);

-- MWST / VAT
-- friendly-name: what users want on their invoice.
-- name: Lebensmittelertrag.
-- friendly_name: Essen.
create table bellevue.taxes (
	id INT generated by default as identity primary key,
	mwst_satz SMALLINT not null
	    CHECK (mwst_satz between 0 and 10000), -- 8.1% => 810
	code TEXT unique, -- z.B. B81
	name TEXT,
	friendly_name TEXT,
	description TEXT,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);


create table bellevue.financial_accounts (
	id INT generated by default as identity primary key,
	code INT unique, -- 3000, 3xxx
	name TEXT not null, -- Verpflegung, Kiosk
	description TEXT,
	tax_id INT not null references bellevue.taxes(id) on delete restrict,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);

create table bellevue.products (
	id INT generated by default as identity primary key,
	name TEXT not null,
	description TEXT,
	financial_account_id INT not null references bellevue.financial_accounts(id) on delete restrict,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);

create table bellevue.prices (
	id INT generated by default as identity primary key,
	price INT not null, -- 11.00 CHF => 1100
	product_id INT
		not null
		references bellevue.products(id)
		on delete restrict,
	price_category_id INT -- reduced, regular, surplus
		not null
		references bellevue.price_categories(id)
		on delete restrict,

	valid_from DATE not null default current_date,
	valid_to   DATE,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);

-- one active row per product+category
create unique index prices_active_unique
on bellevue.prices (product_id, price_category_id)
where valid_to is null;


create table bellevue.consumptions (
	id BIGINT generated by default as identity primary key,
	product_id INT
		not null
		references bellevue.products(id)
		on delete restrict,
	price INT, -- 11.00 CHF => 1100, this is a nonmutable fact, therefore, no ID ref is necessary
	price_id INT -- for analytics
		not null
		references bellevue.prices(id)
		on delete restrict,
	mwst_id INT
		not null
		references bellevue.taxes(id)
		on delete restrict,
	mwst_price INT,
	date DATE,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);


----------------------------------------------------------------------------------
-- models for forms: -------------------------------------------------------------

SET search_path TO bellevue;

-- new activity form
-- Date    => ActivityDate
-- Counter => Breakfast
-- Counter => Lunch
-- Counter => Dinner
-- Counter => Coffee
-- Counter => Lecture
-- Number  => Kiosk
-- Text    => Comment
-- each needs Label and name-prop

-- Prices may vary (e.g. reduced 11, regular 13, surplus 15)
-- maybe fetch price info from the products/price_category/prices table?
-- or define counter with select options?

-- e.g. NewActivityForm
create table forms (
	id                    SERIAL8 primary key,
	name                  STRING not null,
	associated_product_id INT8 references products (id),
	is_active             BOOL default true not null,
	version               INT8 default 1 not null,
	created_at            TIMESTAMPTZ default now() not null
);

-- "text", "textarea", "number", "date", "counter", "select", "checkbox"
create table field_types (
	id   smallserial primary key,
	name text unique not null
);

create table form_fields (
	id            SERIAL8 primary key,
	form_id       INT8 not null references forms (id) on delete cascade,
	name          STRING not null,
	label         STRING not null,
	field_type_id INT2 not null references field_types (id),
	position      INT8 default 0 not null,
	required      BOOL default false not null,
	default_value STRING,
	help_text     STRING,
	min_numeric   DECIMAL,
	max_numeric   DECIMAL,
	pattern       STRING,
	unique (form_id, name)
);

-- Discrete options for select/radio/checkbox,
-- e.g. [ ] male [ ] female [ ] other
create table form_field_options (
	id         SERIAL8 primary key,
	field_id   INT8 not null references form_fields (id) on delete cascade,
	value      STRING not null,
	label      STRING not null,
	position   INT8 default 0 not null,
	unique (field_id, value)
);

-- Submissions
create table form_submissions (
	id           SERIAL8 primary key,
	form_id      INT8 not null references forms (id) on delete restrict,
	submitted_at TIMESTAMPTZ default now() not null,
	submitted_by UUID,
	unique (form_id, id)
);

-- Submitted values (EAV)
create table form_submission_values (
	submission_id INT8 not null references form_submissions (id) on delete cascade,
	field_id      INT8 not null references form_fields (id) on delete restrict,
	value_text    STRING,
	primary key (submission_id, field_id)
);

----------------------------------------------------------------------------------
-- Update Permissions: -----------------------------------------------------------

GRANT SELECT, INSERT, UPDATE, DELETE
ON ALL TABLES IN SCHEMA bellevue
TO app;

GRANT USAGE, SELECT, UPDATE
ON ALL SEQUENCES IN SCHEMA bellevue
TO app;

COMMIT;

-- last migration step is updating public.schema_migrations.
-- app has no permissions. so use dev.
SET ROLE dev;
