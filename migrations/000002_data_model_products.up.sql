BEGIN;

----------------------------------------------------------------------------------
-- user authentication and sessions (cookies) relations:

create table bellevue.users (
	    id              SERIAL primary key,
	    first_name      TEXT not null,
	    last_name       TEXT not null,
	    email           TEXT not null unique,
	    method          TEXT not null,

		-- email / password logins:
	    hashed_password CHAR(60),
		-- openid connect logins:
	    sub             TEXT unique,

		created_at      timestamptz NOT NULL DEFAULT now(),

	CHECK (
		case
			when method = 'password'
			then hashed_password is not null

			when method = 'openidconnect'
			then sub is not null

			else false -- reject unknown methods
		end
	)
);

-- https://pkg.go.dev/github.com/alexedwards/scs/postgresstore#section-readme
-- https://pkg.go.dev/github.com/alexedwards/scs/pgxstore#section-readme
create table bellevue.sessions (
	token  text primary key,
	data   bytea not null,
	expiry timestamptz not null
);

create index sessions_expiry_idx
on sessions (expiry);

alter table bellevue.users
owner to dev;

alter table bellevue.sessions
owner to dev;

grant select, insert, update, delete
on table users, sessions
to app;

grant usage, select, update
on sequence users_id_seq
to app;


----------------------------------------------------------------------------------
-- create a generic model for products and prices --------------------------------
--
-- NOTE:
-- ANSISQL is current_timestamp, PostgreSQL is now() (but you can use both in PG).
-- It refers to the start of the transaction, not point of execution.
--
-- NOTE:
-- use `id INT generated by default as identity primary key,` instead
-- of `id serial`, see https://stackoverflow.com/a/55300741/14501123

-- names: reduced, regular, surplus
create table bellevue.price_categories (
	id          INT
	            generated by default as identity
	            primary key,
	name        TEXT unique not null,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);

-- MWST / VAT
-- friendly-name: what users want on their invoice.
create table bellevue.taxes (
	id            INT
	              generated by default as identity
	              primary key,
	mwst_satz     SMALLINT not null
	              CHECK (mwst_satz between 0 and 10000), -- 8.1% => 810
	code          TEXT unique, -- z.B. B81
	name          TEXT,
	friendly_name TEXT,
	description   TEXT,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);


-- name: Lebensmittelertrag.
-- friendly_name: Essen.
create table bellevue.financial_accounts (
	id          INT
	            generated by default as identity
	            primary key,
	tax_id      INT not null
	            references bellevue.taxes(id),
	code        INT unique, -- 3000, 3xxx
	name        TEXT not null, -- e.g. "Einnahmen diverse Nebenleistungen"
	description TEXT,

	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);

-- valid_from: do you need valid_to? I don't think so, just use
-- whatever is max(valid_to) that is smaller than today.
-- or skip entirely and introduce on requested feature?
create table bellevue.products (
	id                   INT
	                     generated by default as identity
	                     primary key,
	financial_account_id INT
	                     not null
	                     references bellevue.financial_accounts(id),
	price_category_id    INT
	                     references bellevue.price_categories(id),
	                     check (
	                       (pricing_mode = 'fixed'  and price_category_id is not null) or
	                       (pricing_mode = 'custom' and price_category_id is null)
	                     ),

	tax_id               INT
	                     not null
	                     references bellevue.taxes(id),
	name                 TEXT not null, -- e.g. Breakfast, may be translated
	code                 TEXT not null, -- e.g. breakfasts, used internally, for instance for forms
	pricing_mode         TEXT
	                     not null
	                     default 'fixed'
                         check (pricing_mode in ('fixed', 'custom')),
	price                INT -- 11.00 CHF => 1100
	                     check (
	                       (pricing_mode = 'fixed'  and price is not null) or
	                       (pricing_mode = 'custom' and price is null)
	                    ),
	valid_from           TIMESTAMPTZ not null default now(),

	unique (name, price_category_id, valid_from),


	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,
	deleted_at TIMESTAMPTZ
);

create table bellevue.product_form_order (
	code       text primary key,
	sort_order int not null
);

create table bellevue.comments (
	user_id    INT  not null references bellevue.users(id),
	date       DATE not null,
	comment    TEXT,
	created_at TIMESTAMPTZ default now() not null,
	updated_at TIMESTAMPTZ default now() not null,

	primary key (user_id, date)
);


-- TODO: how should I invoice consumptions?
create table bellevue.invoices_v2 (
	id          serial primary key,
	user_id     int not null references bellevue.users(id),
	period_from date not null,
	period_to   date not null,
	status      text not null default 'draft'
	            check (status in ('draft', 'sent', 'paid', 'cancelled')),

	created_at  timestamptz not null default now(),
	updated_at  timestamptz not null default now(),

	unique (user_id, period_from, period_to)
);


-- TODO: should I keep the following column column?
--	mwst_price INT not null, -- unmutable fact
-- NOTE: if invoice_id is null, editable
create table bellevue.consumptions (
	id          BIGINT generated by default as identity primary key,
	user_id     INT not null
	            references bellevue.users(id),
	product_id  INT not null
	            references products(id),
	tax_id      INT not null
	            references taxes(id),
	pricecat_id INT
	            references price_categories(id),
	invoice_id  int
	            references invoices_v2(id),
	date        DATE,
	unit_price  INT not null, -- unmutable fact after invoice_id is not null
	quantity    int not null
                    check (quantity > 0),
	total_price int generated always as (quantity * unit_price) stored,


	created_at TIMESTAMPTZ default now() not null
);

create index on bellevue.consumptions (user_id);
create index on bellevue.consumptions (invoice_id);
create index on bellevue.consumptions (date);


----------------------------------------------------------------------------------
-- Update Permissions: -----------------------------------------------------------

alter table price_categories
owner to dev;

alter table taxes
owner to dev;

alter table financial_accounts
owner to dev;

alter table products
owner to dev;

alter table product_form_order
owner to dev;

alter table comments
owner to dev;

alter table consumptions
owner to dev;

GRANT SELECT, INSERT, UPDATE, DELETE
ON ALL TABLES IN SCHEMA bellevue
TO app;

GRANT USAGE, SELECT, UPDATE
ON ALL SEQUENCES IN SCHEMA bellevue
TO app;

COMMIT;
