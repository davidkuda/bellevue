package models

import (
	"context"
	"database/sql"
	"fmt"
	"time"
)

type BellevueActivityModel struct {
	DB *sql.DB
}

type BellevueActivities []BellevueActivity

// This struct keeps track of things you need to pay for.
type BellevueActivity struct {
	ID         int // auto-generated by postgres
	UserID     int
	Date       time.Time
	Breakfasts int
	Lunches    int
	Dinners    int
	Coffees    int
	Saunas     int
	SnacksCHF  int
	Lectures   int
	Comment    string
	TotalPrice int    // in Rappen => CHF => float64(TotalCost) / 100.0
	Items      []Item // this is a representation that is used in a template to render the data in the table "bellevue-activities"
}

func (m *BellevueActivityModel) GetByMonth() {}

func (m *BellevueActivityModel) Insert(a *BellevueActivity) error {

	var err error

	ctx := context.TODO()
	tx, err := m.DB.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed starting transaction: %e", err)
	}

	// if new month:
	// create a new invoice
	// else:
	// use ID of existing invoice
	stmt := `
	INSERT INTO bellevue_origins (
		user_id,
		activity_date,
		breakfast_count,
		lunch_count,
		dinner_count,
		coffee_count,
		sauna_count,
		lecture_count,
		snacks_chf,
		comment,
		total_price
	) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
	);
	`

	a.CalculatePrice()

	_, err = tx.Exec(
		stmt,
		a.UserID,
		a.Date,
		a.Breakfasts,
		a.Lunches,
		a.Dinners,
		a.Coffees,
		a.Saunas,
		a.Lectures,
		a.SnacksCHF,
		a.Comment,
		a.TotalPrice,
	)
	if err != nil {
		tx.Rollback()
		return fmt.Errorf("failed executing insert sql: %v", err)
	}

	selectInvoiceStmt := `
	select
		id,
		total_price_rappen,
		total_eating,
		total_coffee,
		total_lecture,
		total_sauna,
		total_kiosk,
		state
	from invoices
	where
		user_id = $1
		and period = date_trunc('month', current_date)::date
	`
	row := tx.QueryRow(selectInvoiceStmt, a.UserID)
	var invoice Invoice
	err = row.Scan(
		&invoice.ID,
		&invoice.TotalPrice,
		&invoice.TotalEating,
		&invoice.TotalCoffees,
		&invoice.TotalLectures,
		&invoice.TotalSaunas,
		&invoice.TotalKiosk,
		&invoice.State,
	)
	var isNewInvoice bool
	if err != nil {
		if err == sql.ErrNoRows {
			isNewInvoice = true
		} else {
			tx.Rollback()
			return fmt.Errorf("failed reading invoice: %v", err)
		}
	}

	var totalEating, totalCoffee, totalLecture, totalSauna, totalKiosk int

	totalEating =
		invoice.TotalEating +
			a.Breakfasts*800 +
			a.Lunches*1100 +
			a.Dinners*1100

	totalCoffee = invoice.TotalCoffees + a.Coffees*100

	totalLecture = invoice.TotalLectures + a.Lectures*1200

	totalSauna = invoice.TotalSaunas + a.Saunas*750

	totalKiosk = invoice.TotalKiosk + a.SnacksCHF

	if isNewInvoice {
		insertInvoice := `
		INSERT INTO invoices (
			user_id,
			period,
			total_price_rappen,
			total_eating,
			total_coffee,
			total_lecture,
			total_sauna,
			total_kiosk
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8
		);
		`

		firstOfMonth := time.Date(
			time.Now().Year(),
			time.Now().Month(),
			1, 0, 0, 0, 0,
			time.Now().Location(),
		)

		_, err = tx.Exec(
			insertInvoice,
			a.UserID,
			firstOfMonth,
			invoice.TotalPrice+a.TotalPrice,
			totalEating,
			totalCoffee,
			totalLecture,
			totalSauna,
			totalKiosk,
		)
		if err != nil {
			tx.Rollback()
			return fmt.Errorf("failed inserting new invoice: %v", err)
		}
	} else {
		updateInvoice := `
		UPDATE invoices
		SET
			total_price_rappen = $1,
			total_eating = $2,
			total_coffee = $3,
			total_lecture = $4,
			total_sauna = $5,
			total_kiosk = $6
		WHERE id = $7;
		`

		_, err = tx.Exec(
			updateInvoice,
			invoice.TotalPrice+a.TotalPrice,
			totalEating,
			totalCoffee,
			totalLecture,
			totalSauna,
			totalKiosk,
			invoice.ID,
		)
		if err != nil {
			tx.Rollback()
			return fmt.Errorf("failed inserting new invoice: %v", err)
		}
	}

	tx.Commit()
	return nil
}

func (m *BellevueActivityModel) Update(a *BellevueActivity) error {
	stmt := `
	UPDATE bellevue_origins
	SET
		activity_date = $1,
		breakfast_count = $2,
		lunch_count = $3,
		dinner_count = $4,
		coffee_count = $5,
		sauna_count = $6,
		lecture_count = $7,
		snacks_chf = $8,
		comment = $9,
		total_price = $10
	WHERE id = $11;
	`

	a.CalculatePrice()

	_, err := m.DB.Exec(
		stmt,
		a.Date,
		a.Breakfasts,
		a.Lunches,
		a.Dinners,
		a.Coffees,
		a.Saunas,
		a.Lectures,
		a.SnacksCHF,
		a.Comment,
		a.TotalPrice,
		a.ID,
	)
	if err != nil {
		return fmt.Errorf("failed executing UPDATE sql: %v", err)
	}

	return nil
}

func (m *BellevueActivityModel) Delete(activityID int) error {
	stmt := `
	DELETE from bellevue_origins
	WHERE id = $1;
	`

	_, err := m.DB.Exec(stmt, activityID)
	if err != nil {
		return fmt.Errorf("failed executing DELETE sql: %v", err)
	}

	return nil
}

func (m *BellevueActivityModel) GetAllByUser(userID int) (BellevueActivities, error) {
	stmt := `
	SELECT
		id,
		activity_date,
		breakfast_count,
		lunch_count,
		dinner_count,
		coffee_count,
		sauna_count,
		lecture_count,
		snacks_chf,
		total_price,
		comment
	FROM bellevue_origins
	WHERE user_id = $1
	ORDER BY activity_date DESC
	`

	rows, err := m.DB.Query(stmt, userID)
	if err != nil {
		return nil, fmt.Errorf("DB.Query(stmt): %v", err)
	}

	defer rows.Close()

	var bas BellevueActivities

	for rows.Next() {
		var ba BellevueActivity
		err = rows.Scan(
			&ba.ID,
			&ba.Date,
			&ba.Breakfasts,
			&ba.Lunches,
			&ba.Dinners,
			&ba.Coffees,
			&ba.Saunas,
			&ba.Lectures,
			&ba.SnacksCHF,
			&ba.TotalPrice,
			&ba.Comment,
		)
		if err != nil {
			return nil, fmt.Errorf("for rows.Next(): %v", err)
		}
		ba.PopulateItems()
		bas = append(bas, ba)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("rows.Err(): %v", err)
	}

	return bas, nil
}

func (m *BellevueActivityModel) GetActivitiesOfPreviousMonth(userID int) (BellevueActivities, error) {
	stmt := `
	SELECT
		id,
		activity_date,
		breakfast_count,
		lunch_count,
		dinner_count,
		coffee_count,
		sauna_count,
		lecture_count,
		snacks_chf,
		total_price,
		comment
	FROM bellevue_origins
	WHERE
		user_id = $1
		AND date_trunc('month', activity_date)::date
			= date_trunc(
					'month',
					current_date - interval '1 month'
			)::date
	ORDER BY activity_date ASC;
	`

	rows, err := m.DB.Query(stmt, userID)
	if err != nil {
		return nil, fmt.Errorf("DB.Query(stmt): %v", err)
	}

	defer rows.Close()

	var bas BellevueActivities

	for rows.Next() {
		var ba BellevueActivity
		err = rows.Scan(
			&ba.ID,
			&ba.Date,
			&ba.Breakfasts,
			&ba.Lunches,
			&ba.Dinners,
			&ba.Coffees,
			&ba.Saunas,
			&ba.Lectures,
			&ba.SnacksCHF,
			&ba.TotalPrice,
			&ba.Comment,
		)
		if err != nil {
			return nil, fmt.Errorf("for rows.Next(): %v", err)
		}
		ba.CalculatePrice()
		bas = append(bas, ba)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("rows.Err(): %v", err)
	}

	return bas, nil
}

func (m *BellevueActivityModel) ActivityOwnedByUserID(activityID, userID int) (bool, error) {
	stmt := `
	SELECT user_id
	FROM bellevue_origins
	WHERE id = $1
	`

	row := m.DB.QueryRow(stmt, activityID)

	var idFromDB int

	err := row.Scan(&idFromDB)
	if err != nil {
		return false, fmt.Errorf("failed fetching row; activityID=%d, userID=%d: %v", activityID, userID, err)
	}

	return idFromDB == userID, nil
}

func (m *BellevueActivityModel) MaxID() (int, error) {
	stmt := `
	SELECT count(id)
	FROM bellevue_origins
	`

	row := m.DB.QueryRow(stmt)

	var N int

	err := row.Scan(&N)
	if err != nil {
		return 0, err
	}

	return N, nil
}

func (m *BellevueActivityModel) GetByID(activityID int) (*BellevueActivity, error) {
	stmt := `
	SELECT
		id,
		user_id,
		activity_date,
		breakfast_count,
		lunch_count,
		dinner_count,
		coffee_count,
		sauna_count,
		lecture_count,
		snacks_chf,
		total_price,
		comment
	FROM bellevue_origins
	WHERE id = $1
	`

	row := m.DB.QueryRow(stmt, activityID)

	var act BellevueActivity

	err := row.Scan(
		&act.ID,
		&act.UserID,
		&act.Date,
		&act.Breakfasts,
		&act.Lunches,
		&act.Dinners,
		&act.Coffees,
		&act.Saunas,
		&act.Lectures,
		&act.SnacksCHF,
		&act.TotalPrice,
		&act.Comment,
	)
	if err != nil {
		return nil, fmt.Errorf("failed fetching row; activityID=%d: %v", activityID, err)
	}

	return &act, nil
}
